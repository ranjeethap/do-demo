name: CI/CD to DOKS (DOCR + kubectl)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

env:
  IMAGE_REGISTRY: registry.digitalocean.com
  NS: dev
  DEPLOYMENT: doks-flask
  SERVICE: doks-flask

jobs:
  build_push_deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_TOKEN }}

      - name: Preflight (secrets and registry)
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${{ secrets.DOCR_REGISTRY }}" || -z "${{ secrets.DOCR_REPO }}" ]]; then
            echo "DOCR_REGISTRY/DOCR_REPO secrets are missing"; exit 1;
          fi
          IMAGE="${IMAGE_REGISTRY}/${{ secrets.DOCR_REGISTRY }}/${{ secrets.DOCR_REPO }}"
          echo "IMAGE=${IMAGE}"
          if ! [[ "${IMAGE}" =~ ^registry\.digitalocean\.com/[a-z0-9-]+/[a-z0-9-]+$ ]]; then
            echo "Bad IMAGE path: ${IMAGE}"; exit 1;
          fi
          # Confirm the registry is visible to this team token
          doctl registry get 1>/dev/null

      - name: Login to DOCR (write)
        shell: bash
        run: doctl registry login

      - name: Compute image name/tags
        id: img
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="${IMAGE_REGISTRY}/${{ secrets.DOCR_REGISTRY }}/${{ secrets.DOCR_REPO }}"
          echo "image=${IMAGE}" >> "$GITHUB_OUTPUT"
          echo "tag_sha=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"

      - name: Build image
        shell: bash
        run: |
          set -euo pipefail
          docker build -f Dockerfile \
            -t "${{ steps.img.outputs.image }}:${{ steps.img.outputs.tag_sha }}" \
            -t "${{ steps.img.outputs.image }}:latest" \
            .

      - name: Push image
        shell: bash
        run: |
          set -euo pipefail
          docker push "${{ steps.img.outputs.image }}:${{ steps.img.outputs.tag_sha }}"
          docker push "${{ steps.img.outputs.image }}:latest"

            - name: Write kubeconfig (robust)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.kube"

          # Try to decode as base64; if that fails, treat the secret as raw kubeconfig
          if echo "${{ secrets.KUBECONFIG_B64 }}" | base64 -d >/dev/null 2>&1; then
            echo "${{ secrets.KUBECONFIG_B64 }}" | base64 -d > "$HOME/.kube/config"
            echo "Wrote kubeconfig from BASE64 secret."
          else
            printf '%s' "${{ secrets.KUBECONFIG_B64 }}" > "$HOME/.kube/config"
            echo "Wrote kubeconfig from RAW secret."
          fi

          # Basic sanity check
          kubectl config current-context || true

      - name: Ensure namespace and DOCR pull secret
        shell: bash
        run: |
          set -euo pipefail
          kubectl get ns "${NS}" >/dev/null 2>&1 || kubectl create ns "${NS}"
          # Create a short-lived docker config from doctl for the pull secret
          mkdir -p "$HOME/.docker"
          doctl registry docker-config --read-write --expiry-seconds 1800 > "$HOME/.docker/config.json"
          kubectl -n "${NS}" delete secret do-docr-secret >/dev/null 2>&1 || true
          kubectl -n "${NS}" create secret generic do-docr-secret \
            --type=kubernetes.io/dockerconfigjson \
            --from-file=.dockerconfigjson="$HOME/.docker/config.json"
          kubectl -n "${NS}" patch serviceaccount default \
            -p '{"imagePullSecrets":[{"name":"do-docr-secret"}]}' || true

      - name: Deploy/Update app in DEV
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="${{ steps.img.outputs.image }}:${{ steps.img.outputs.tag_sha }}"

          # If deployment exists, set image; else create a minimal deployment
          if kubectl -n "${NS}" get deploy "${DEPLOYMENT}" >/dev/null 2>&1; then
            kubectl -n "${NS}" set image deploy/${DEPLOYMENT} app="${IMAGE}"
          else
            kubectl -n "${NS}" create deployment "${DEPLOYMENT}" \
              --image="${IMAGE}" \
              --port=8080
            # Patch in readiness/liveness and pull secret quickly
            kubectl -n "${NS}" patch deployment "${DEPLOYMENT}" --type='json' -p='[
              {"op":"add","path":"/spec/template/spec/imagePullSecrets","value":[{"name":"do-docr-secret"}]},
              {"op":"add","path":"/spec/template/spec/containers/0/readinessProbe","value":{"httpGet":{"path":"/healthz","port":8080},"initialDelaySeconds":3,"periodSeconds":5}},
              {"op":"add","path":"/spec/template/spec/containers/0/livenessProbe","value":{"httpGet":{"path":"/healthz","port":8080},"initialDelaySeconds":10,"periodSeconds":10}}
            ]'
            kubectl -n "${NS}" scale deploy "${DEPLOYMENT}" --replicas=2
          fi

          # Ensure Service exists
          if ! kubectl -n "${NS}" get svc "${SERVICE}" >/dev/null 2>&1; then
            kubectl -n "${NS}" expose deployment "${DEPLOYMENT}" \
              --name "${SERVICE}" \
              --port 80 --target-port 8080
          fi

          # Wait for rollout
          kubectl -n "${NS}" rollout status deploy/${DEPLOYMENT} --timeout=300s

      - name: Show running pods/images
        shell: bash
        run: |
          set -euo pipefail
          kubectl -n "${NS}" get pods -l app=${DEPLOYMENT} \
            -o jsonpath='{range .items[*]}{.metadata.name}{" -> "}{.spec.containers[0].image}{"\n"}{end}'