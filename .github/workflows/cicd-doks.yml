name: CI/CD to DOKS (DOCR)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

env:
  DOCR_REGISTRY: registry.digitalocean.com/dokr-saas
  DOCR_REPO: doks-flask
  IMAGE: ${{ secrets.DOCR_REGISTRY }}/${{ secrets.DOCR_REPO }}

jobs:
  build_push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          test -n "${{ secrets.DO_TOKEN }}" || { echo "Missing DO_TOKEN"; exit 1; }
          test -n "${{ secrets.DOCR_REGISTRY }}" || { echo "Missing DOCR_REGISTRY"; exit 1; }
          test -n "${{ secrets.DOCR_REPO }}" || { echo "Missing DOCR_REPO"; exit 1; }
          test -n "${IMAGE}" || { echo "Derived IMAGE is empty"; exit 1; }
          echo "IMAGE is set (masked in logs): ${IMAGE}"

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_TOKEN }}

      - name: Login to DOCR
        run: doctl registry login

      - name: Build image
        run: |
          docker build -t $IMAGE:${{ github.sha }} -t $IMAGE:latest ./app

      - name: Push image
        run: |
          docker push $IMAGE:${{ github.sha }}
          docker push $IMAGE:latest

  deploy:
    needs: build_push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_TOKEN }}

      - name: Pick cluster (dev by default; override with workflow_dispatch)
        id: pick
        shell: bash
        run: |
          env_input='${{ github.event.inputs.target_env }}'
          if [[ -z "$env_input" ]]; then env_input="dev"; fi
          if [[ "$env_input" != "prod" ]]; then env_input="dev"; fi
          echo "env=$env_input" >> $GITHUB_OUTPUT
          if [[ -n "${{ github.event.inputs.target_cluster }}" ]]; then
            echo "cluster=${{ github.event.inputs.target_cluster }}" >> $GITHUB_OUTPUT
          else
            if [[ "$env_input" == "prod" ]]; then
              echo "cluster=${{ secrets.DO_CLUSTER_PROD }}" >> $GITHUB_OUTPUT
            else
              echo "cluster=${{ secrets.DO_CLUSTER_DEV }}" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Save kubeconfig for target cluster
        run: doctl kubernetes cluster kubeconfig save "${{ steps.pick.outputs.cluster }}"

      - name: Ensure namespace + DOCR pull secret
        env:
          REG: ${{ secrets.DOCR_REGISTRY }}
        run: |
          ns="${{ steps.pick.outputs.env }}"
          kubectl create ns "$ns" --dry-run=client -o yaml | kubectl apply -f -
          reg_name="$(basename "$REG")"
          doctl registry kubernetes-manifest "$reg_name" --namespace "$ns" --name do-docr-secret | kubectl apply -f -
      - name: Resolve Ingress address (ingress-nginx)
      id: ing
      run: |
        for i in {1..60}; do
          ADDR=$(kubectl -n ingress-nginx get svc ingress-nginx-controller \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}{.status.loadBalancer.ingress[0].hostname}' | tr -d ' ')
          if [[ -n "$ADDR" ]]; then
            echo "ADDR=$ADDR"
            break
          fi
          echo "Waiting for ingress address... ($i/60)"; sleep 5
        done
        test -n "$ADDR" || { echo "No ingress address yet"; exit 1; }
        echo "addr=$ADDR" >> "$GITHUB_OUTPUT"

    - name: Render manifests (replace placeholder in ingress hosts)
      env:
        NS: ${{ steps.pick.outputs.env }}       # dev or prod
        ADDR: ${{ steps.ing.outputs.addr }}     # IP or hostname
      run: |
        mkdir -p rendered
        # If your files still use {{ING_IP}}, keep sed target as that token.
        for f in scripts/manifests/${NS}-*.yaml; do
          sed "s/{{ING_IP}}/${ADDR}/g" "$f" > "rendered/$(basename "$f")"
        done
        ls -la rendered

    - name: Apply rendered manifests
      env:
        NS: ${{ steps.pick.outputs.env }}
      run: |
        kubectl apply -f rendered/${NS}-deploy.yaml
        kubectl apply -f rendered/${NS}-svc.yaml
        if [[ "$NS" == "dev" ]]; then kubectl apply -f rendered/${NS}-hpa.yaml; fi
        kubectl apply -f rendered/${NS}-ingress.yaml

